---
Theme: Virtual Memory and Paging
Date created: 2026-01-28 12:00
tags: [ArchitectureLayer, MemoryManagement, VirtualMemory]
---

## ğŸ“š Idea/Concept

Virtual memory is a memory management technique that provides each process with the illusion of a large, contiguous, private address space, while the operating system maps this virtual space to physical memory and disk storage.

### Core Concept

Virtual Address:
- Address generated by CPU/program
- Process-private address space
- Typically larger than physical memory

Physical Address:
- Actual location in RAM
- Shared by all processes
- Managed by OS and hardware

Translation:
- Virtual â†’ Physical mapping
- Performed by Memory Management Unit (MMU)
- Assisted by page tables

### Benefits of Virtual Memory

1. Memory Isolation:
   - Each process has private address space
   - Bugs in one process can't corrupt another
   - Security through isolation

2. Memory Abstraction:
   - Programs see simple linear address space
   - Physical memory fragmentation hidden
   - Simplifies programming

3. Memory Extension:
   - Virtual space can exceed physical memory
   - Unused pages stored on disk (swap)
   - Demand paging loads on access

4. Sharing:
   - Multiple processes can share physical pages
   - Shared libraries loaded once
   - Copy-on-write optimization

### Paging Concept

Virtual address space divided into fixed-size pages.
Physical memory divided into frames of same size.

Typical page sizes:
- 4 KB (most common)
- 2 MB (large pages)
- 1 GB (huge pages)

Address Translation:
```
Virtual Address: [ Virtual Page Number | Page Offset ]
                          â†“
                    Page Table
                          â†“
Physical Address: [ Physical Frame Number | Page Offset ]
```

### Page Table Structure

Each process has a page table containing:
- Valid bit (V): Page present in memory?
- Physical Frame Number (PFN): Where in RAM
- Protection bits (R/W/X): Read, Write, Execute permissions
- Dirty bit (D): Page modified since load?
- Accessed bit (A): Page accessed recently?

Page Table Entry (PTE):
```
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ V â”‚     Frame #       â”‚ D â”‚ A â”‚ R â”‚ W â”‚ X â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
```

### Address Translation Example

32-bit address, 4 KB pages:
- Page offset: 12 bits (logâ‚‚(4096))
- Virtual page number: 20 bits
- 2Â²â° = 1M pages per process

Translation:
```
Virtual: 0x12345678
VPN: 0x12345
Offset: 0x678

Page table lookup: PT[0x12345] â†’ Frame 0x89ABC

Physical: 0x89ABC678
```

### Page Fault

When valid bit = 0 (page not in memory):
1. MMU raises page fault exception
2. OS handles fault:
   - Locate page on disk
   - Find free frame (or evict one)
   - Load page from disk to frame
   - Update page table
   - Restart instruction

### Multi-Level Page Tables

Problem: Flat page table too large
- 32-bit with 4KB pages: 4 MB per process
- 64-bit: Impossibly large

Solution: Hierarchical page tables

Two-Level (32-bit):
```
Virtual Address: [ L1 Index | L2 Index | Offset ]
                     10        10         12

L1 Table â†’ L2 Table â†’ Physical Frame
```

Four-Level (64-bit, x86-64):
```
[ PML4 | PDPT | PD | PT | Offset ]
   9      9     9    9     12
```

Advantage:
- Only allocate page tables for used regions
- Sparse address spaces efficient

### Fragmentation Comparison

| Scheme | Internal Frag | External Frag |
|--------|--------------|---------------|
| Paging | Yes (last page) | None |
| Segmentation | None | Yes |
| Seg + Paging | Minimal | None |

### Page Replacement Policies

When physical memory full:
- FIFO: Replace oldest page
- LRU: Replace least recently used
- Clock: Approximation of LRU
- Working Set: Keep active pages

### Demand Paging

Pages loaded only when accessed:
1. Process starts with no pages in memory
2. Each access causes page fault initially
3. Working set gradually loaded
4. Unused pages never loaded

Advantages:
- Fast process startup
- Only needed pages consume RAM
- More processes fit in memory

## ğŸ“Œ Key Points (Optional)
- Virtual memory enables memory isolation and efficient resource sharing.
- Page tables can be hierarchical to save space for sparse address spaces.

## ğŸ–¼ï¸ Recommended Image
- Diagram showing virtual-to-physical address translation through page table.

## ğŸ”— Connections
- [[096-Translation Lookaside Buffer TLB]]
- [[095-Memory Management Unit MMU]]
- [[086-Memory Hierarchy Principles and Locality]]
- [[Page Table Organization and Hierarchy]]