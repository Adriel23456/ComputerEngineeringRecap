; =======================================================
; Loop using NaN and BORD (Branch if Ordered)
; Inverted logic: continues while the value is NOT NaN
; Expected result: REG1 = 4, REG7 = NaN
; =======================================================
MOVI  REG1, #0             ; REG1 = 0 (counter)
MOVI  REG3, #4             ; REG3 = 4 (limit)
FMOVI REG5, #0.0           ; REG5 = 0.0
FMOVI REG6, #0.0           ; REG6 = 0.0
FDIV  REG7, REG5, REG6     ; REG7 = NaN
.Loop:
  ADDI  REG1, REG1, #1     ; i++
  SUB   REG4, REG1, REG3   ; REG4 = i - 4
  ASRI  REG4, REG4, #31    ; REG4 = -1 if i < 4, 0 if i >= 4
  EORI  REG4, REG4, #-1    ; Invert mask: 0 if i < 4, 0xFFFFFFFF if i >= 4
  AND   REG2, REG7, REG4   ; REG2 = 0.0 if i < 4, NaN if i >= 4
  FCMPS REG2, REG2         ; V=0 if i < 4 (ordered); V=1 if i >= 4 (unordered)
  BORD  .Loop              ; Branch if V=0 (ordered, i < 4)
SWI                        ; Final state: REG1 = 4, REG2 = NaN, REG7 = NaN
